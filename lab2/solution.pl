% Лабораторная работа №2
% Вариант №1
%-------------------------------------------------------------------------------
% Начальные данные:

person("Воронов").
person("Павлов").
person("Левицкий").
person("Сахаров").

proffesion(танцор).
proffesion(художник).
proffesion(певец).
proffesion(писатель).

knows("Левицкий", певец).
knows("Воронов", певец).
knows("Павлов", писатель).
knows(писатель, "Павлов").
knows(писатель, художник).
knows(художник, писатель).
knows(художник, "Павлов").
knows("Павлов", художник).
knows(писатель, "Сахаров").
knows(писатель, "Воронов").

% здесь данные, которые мы знаем точно, что отличается от данных предиката
% not(knows(X, Y)), которые мы не можем доказать, что не одно и тоже
notknows("Воронов", "Левицкий").
%-------------------------------------------------------------------------------

% предикат проверки на уникальность каждого элемента списка
myunique([]).
myunique([H|T]) :- not(member(H, T)), myunique(T).

% предикат истинный если человек знает сам себя
varios(L) :- member(man(X, Y), L), knows(X, Y).
varios(L) :- member(man(X, Y), L), knows(Y, X).

% предикат, истинный, если человек, знающий кого-либо, в это же время
% этого человека не знает
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(X, Q),
  notknows(X, Z).
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(Y, Q),
  notknows(X, Z).

% для решения нашей задачи достаточно только верхнего объявления, однако для
% расширения его области определения допишем еще несколько определений снизу
% что позволит применять нашу программу для других корректных наборов данных
% и сделает нашу программу более гибкой
% Стоит заметить, что так, как применяется предикат в конце определения solve\1
% то значительного увеличения в количестве переборов это не несет
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(X, Q),
  notknows(Y, Q).
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(X, Z),
  notknows(X, Q).
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(X, Z),
  notknows(Y, Q).
helppred(L) :- member(man(X, Y), L),
  member(man(Z, Q), L),
  knows(Y, Q),
  notknows(X, Q).

% предикат выбора всех решений задачи

solve(L) :-
% определяем вид того, как будет выглядеть ответ
% более того, если не инициализировать изначально фамилиями этот список,
% то придется также искать их значения перебором, что в последствии увеличит объем работы по перебору 
% более чем в 24 раза, а так же заставит потом из множества одинаковых семантически ответов 
% искать ответ определенного формата

  L = [man("Воронов", APro), man("Павлов", BPro), man("Левицкий", CPro), man("Сахаров", DPro)],

  % это условие для того, чтобы все люди имели разные профессии, что дано по условию
  % и уменьшает в дальнейшем количество переборов в ~((4^4)/(4!)) раза

  proffesion(APro), proffesion(BPro), proffesion(CPro), proffesion(DPro),
  myunique([APro, BPro, CPro, DPro]),

% это условие просит нас отобрать лишь те возможные вырианты ответов, в которых
% каждый член не знает самого себя, что логично в рамках той смысловой нагрузки,
% что несет в себе предикат knows/2(содержит в себе данные о том, кто кем не является)

  not(varios(L)),

% а здесь делается логическая проверка на случай того, что один человек одновре-
% менно знает и не знает о ком либо, что не возможно по правилу исключения 3-го

  not(helppred(L)).
