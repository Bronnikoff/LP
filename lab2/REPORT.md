#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Бронников М.А. М8О-204Б

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует 2 основных метода решения логических задач: первый- это метод порождения и проверок, а второй- метод ветвей и границ, каждый из которых имеет различные реализации.
Если говорить о 1-ом методе, то это примитивный способ генерации всевозможных вариантов решения, каждый из которых в последствии проходит череду проверок, которые отсекают неподходящие варианты, и переходят к проверке следующего варианта. В случае успеха результат возвращается пользователю, и продолжается дальнейшие проверки остальных вариантов.
Что касается 2-го метода, то он заключатся в том что на каждом этапе решения отсекаются огромные классы неподходящих по каким-либо признакам вариантов, и, даже на этапе генерации этих самых этапов, что позволяет делать меньше переборов по ходу программы.
Из общего эти меоды имеют то, что в каждом способе требуется рассматривать множество возможных решений и отсекать не подходящие варианты.
Пролог для решения таких заданий удобен своим уникальным инструментом - бэктрэкингом, позволяющим при каждой неудаче возвращатся на шаг назад, и продолжать поиск в дереве вариантов используя уже другие значения переменых. Также пролог удобен простотой указания требований к вариантам решений, ведь достаточно просто указать предикат, который должен быть истинным или ложным для искомого варианта.

## Задание

1. Воронов, Павлов, Левицкий и Сахаров четыре талантливых молодых человека. Один из них танцор, другой художник, третий певец, четвертый писатель. Воронов и Левицкий сидели в зале консерватории в тот вечер, когда певец дебютировал в сольном концерте. Павлов и писатель вместе позировали художнику. Писатель написал биографическую повесть о Сахарове и собирается написать о Воронове. Воронов никогда не слышал о Левицком. Кто чем занимается?

## Принцип решения
Имеется предикат поиска решений- solve/1. В нем изначально инициалзируем список, содержащий наш ответ фамилиями людей для того, что бы не писать в дальнейшем предикат выборки решения из множества семантически одинаковых решений с разным порядком разположения в списке, а также для оптимизации решения, ведь такая начальная инициализация уменьшит количество преборов более чем в 4! раза(24 раза).

```
  L = [man("Воронов", APro), man("Павлов", BPro), man("Левицкий", CPro), man("Сахаров", DPro)],
```

Далее начинается генерация вариантов ответов, в количестве 4^4 вариантов ответа

```
  proffesion(APro), proffesion(BPro), proffesion(CPro), proffesion(DPro),
```

И следуюшая далее выборка из этих 4^4 вариантов 4! вариантов, которые будут рассматриватся далее, так как мы знаем, что несколько лиц не могут владеть разными профессиями. Для этого используем предикат myunique/1, который истиннен только при условии того, что каждый элемент списка уникален.

```
myunique([APro, BPro, CPro, DPro]),
```

После отбираем варианты, если каждая персона в списке не знает себя(что парадокасально на первый взгляд, однако, если персона знает ряд лиц, то совершенно точно в контексе нашего задания этими лицами она являтся не будет, а это значит надо искать из списка тех, кто сам себя не знает).
Предикат varios/1 истинен, если хотя бы один элемент списка знает сам себя(что не может быть, а значит используем отрицание).

```
not(varios(L)),
```

И наконец финальная проверка на случай того, если персона знает кого-либо, и одновременно с этим не знает кого либо, то вызывает противоречия по закону исключения 3-го
Предикат helppred/1, если ххотя бы один элемент списка знает другой по его профессии или фамилии, и в то же время не знаком с ним по этим признакам.

```
  not(helppred(L)).
```

В результате всех переборов и ограничений получаем следующий результат:

```
?- solve(L).
L = [man("Воронов", танцор), man("Павлов", певец), man("Левицкий", писатель), man("Сахаров", художник)] ;
false.
```

## Выводы

Эта лабораторная работа показала как можно решать логические задачи путем составления программ.
В результате решения возник вопрос о целесообразности решения таких задач программно-аппаратным методом, на который я ответил себе следующим образом: это следует делать только при очень большом объеме начальных данных, так как при задачах с небольшим количеством исходных данных, как в той, что нам пришлось решить, легче и быстрее сделать это на бумаге, чем писать программу. 
Данная работа научила меня не только писать программы, позволяющие решать небольшие классы логических задач с корректными ответами, но и при описании алгоритма каждый раз задаваться вопросом: "Насколько эффективно то или инное действие и каковы будут его последствия в дальнейшем?". Я открыл для себя, что поменяв одну строчку можно сократить время работы программы в сотни раз.
К тому же я получил опыт в создании программ, специализирующихся на переборе вариантов и познакомился некоторыми особенностями языка Пролог, помогающих в этом, таких как бэктрэкинг и встроенный предикат not.





