# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Бронников М. А. М8О-204Б

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

 Списки - мощный инструмент для работы с данными в прологе, именно поэтому важно научится с ними работать. По своей структуре и реализации похожи на списки в Лиспе, а если рассматривать императивные языки программирования, то существует сходство со списками в Питон и массивами в Си и Си-подобных языках.
 Отличие списков в Прологе от списков в императивных языках -это то, как программист получает доступ к данным структуры: в Прологе это делается рекурсивно, а в императивых языках с использованием итераторов. Cтоит заметить, что несмотря на сходства структуры список в Пролог со структурами данных в императивных языках, технология программирования различается до неузнаваемости: в императивных языках программист описывает компьютеру как получить ответ, когда как в декларативных он говорит ему то, что ожидает получить. Недаром декларативные и императивные языки- две разных парадигмы.

## Задание 1.1: Предикат обработки списка

first_pred в 2-ух реализациях удаляет последний элемент в списке.
Примеры использования:
```
?- first_pred([1, 656, 32, 56], L).
L = [1, 656, 32].

?- first_pred([1, vk, fsvsv, 245, f, "tvsss", fsvs], L).
L = [1, vk, fsvsv, 245, f, "tvsss"].

?- first_pred([1], L).
L = [].

?- first_pred([kvnkl, 654], L).
L = [kvnkl].

?- first_pred([], L).
false.

?- myfirst_pred([1, fsvs, fvsvs, "FSFVS", 54, sfvs], L).
L = [1, fsvs, fvsvs, "FSFVS", 54].

?- myfirst_pred([1, 4, 5, 9], L).
L = [1, 4, 5].

?- myfirst_pred([1], L).
L = [].

?- myfirst_pred([], L).
false.

?- myfirst_pred([lkm, "sfsfvs"], L).
L = [lkm].
```

Реализация:
```
% first realisation of predicate for working with lists from varios №2:
% Delete last element in list

myfirst_pred([H], []) :- !.
myfirst_pred([P,_], [P]) :- !.
myfirst_pred([H|T], [H|TR]) :- myfirst_pred(T, TR).

% second realisation with library predicates

first_pred(L, X):-reverse(L, [H|T]), reverse(T, X).
```
reverse - не является стандартным предикатом

first_pred переворачивает список, и возвращает перевернутый "хвост" без "головы"
myfirst_pred рекурсивно проходит по списку пока не дойдет до последнего элемента, который не включается в возвращаемый список. Таким образом головы на каждом этапе рекурсии остаются нетронутыми, а изменяются хвосты.

## Задание 1.2: Предикат обработки числового списка

Предикат проверяет упорядоченность по возрастанию.
Примеры использования:
```
?- second_pred([1, 2, 3, 4, 5, 8]).
true.

?- second_pred([]).
true.

?- second_pred([4]).
true.

?- second_pred([3, 5, 2, 9]).
false.

?- second_pred([3, 5, 5, 9, 11]).
false.

?- mysecond_pred([1, 4, 9, 11]).
true.

?- mysecond_pred([]).
true.

?- mysecond_pred([7]).
true.

?- mysecond_pred([4, 1, 6, 3, 6, 9]).
false.

?- mysecond_pred([6, 9]).
true.

?- mysecond_pred([5, 8, 8, 9, 11]).
false.
```

Реализация:
```
% first realisation of predicate for works with list of numbers from varios №7:
% Check list of numbers on sort elements position 

mysecond_pred([]).
mysecond_pred([H]):-!.
mysecond_pred([H|[Hd|T]]):- H < Hd, mysecond_pred([Hd|T]).

% second realisation with library predicates
second_pred(L):-sort(L, L).
```
mysecond_pred на каждом этапе рекурсии сравнивает "голову" и "голову хвоста" данного списка, пока не дойдет до одинарного элемента, что означает истинное значение.
second_pred истинно если отсортированный список совпадает со списком.

## Задание 2: Реляционное представление данных

 Реляционное представление описывает объекты изучения с помощью связей этих объектов с объектами других других типов. Поэтому для получения информации об интересующем объекте программист должен делать запросы к реляционной модели с целью получения некоторого множества ответов, которые удовлетворяют структуре и логике программы. Такая методика работы обязывает программиста разбивать решение макрозадачи на подзадачи, каждую из которых приходится решать как отдельно, так и совместно. Стоит сказать что я не раз сталкивался с ситуацией, когда получаемый мной результат охватывал или не все необходимые, или лишние объекты из-за неверного построения обработки связей в реляционном представлении.
 Мое представление- список всех оценок, с указанием предмета, по которому получена оценка, ученика, получившего ее и группы студента. К преемуществам такого представления можно отнести то, что информация по оценке представлена одним предикатом, что помогает задавать связи между объектами, особенно, когда речь идет об оценках. К недостаткам следует отнести то, что каждый раз, когда нас интересует общая статистика, требующая получения информации от обработки всей реляционной модели, приходится обрабатывать все предикаты при помощи setof и findall. Однако считаю, что мое представление самое удобное для работы из 4-ех возможных. 
 2 вариант.
 1 задание: Напечатать средний балл для каждого предмета.
 
 Примеры использования:
 ```
 ?- av_score('Информатика', N).
N = 3.9285714285714284.

?- av_score('Логическое программирование', N).
N = 3.9642857142857144.

?- av_score('Математический анализ', N).
N = 3.892857142857143.

?- av_score('Психология', N).
N = 3.9285714285714284.

?- av_score('Английский язык', N).
N = 3.75.
 ```
 Реализация:
 ```
 % predicat for find sum os list elems
sum_list([], 0).
sum_list([H|T], N) :- sum_list(T, M), N is H + M.

% predicat for find average score of subject
av_score(Sub, N) :-
  findall(Grade, grade(_,_,Sub,Grade), Grades),
  sum_list(Grades, M),
  length(Grades, C),
  N is M/C.
 ```
 Сначала описываем предикат нахождения суммы списка рекурсивной обработкой этого списка.
 Для нахождения средней оценки по предметам нам необходимо найти сумму всех оценок по этим предметам и количество этих предметов, где искомым будет их частное. Для этого добавляем в список все оценки, если они удовлетворяют предмету с помощью findall, далее ищем сумму оценок с помощью описанной нами функции, а длина списка- количество оценок, от сюда ищем среднюю оценку.
 
 2 задание: Для каждой гркппы найти количество несдавших студентов.
 
 Примеры использования:
 ```
 ?- person_from_group(101, N).
N = 2.

?- person_from_group(102, N).
N = 5.

?- person_from_group(103, N).
N = 3.

?- person_from_group(104, N).
N = 2.
 ```
 Реализация:
 ```
 person_from_group(Gr, N) :-
  setof(F, C^grade(Gr,F,C,2), List),
  length(List, N).
 ```
 Заполняем список фамилиями всех несдавших в данной группе(setof для того, чтоб одна фамилия не попадала дважды), а затем ищем длину этого списка, что и будет нашим искомым.
 
 3 задание: Найти количество несдавших для кадлого из предметов.
 
 Примеры использования:
 ```
 ?- person_from_subj('Английский язык', N).
N = 4.

?- person_from_subj('Информатика', N).
N = 2.

?- person_from_subj('Логическое программирование', N).
N = 2.

?- person_from_subj('Математический анализ', N).
N = 3.

?- person_from_subj('Психология', N).
N = 1.

?- person_from_subj('Функциональное программирование', N).
N = 1.
 ```
 Реализация:
 ```
 person_from_subj(Sub, N) :-
  findall(1, grade(_,_,Sub,2), List),
  length(List, N).
 ```
 Заполняем список произвольным элементом(в нашем случае 1), если оценка по данному предмету неудовлетворительна, а искомым будет длина этого списка.
 
## Выводы

 При работе над данной лабораторной я узнал, что с помощью реляционного представления можно работать с данными в Прологе. Также я получил опыт работы со списками и встроенными функциями языка. Эта работа во многом поменяла мое представление о программировании, ведь до этого я никогда не работал с декларативными языками, а лишь только с императивными. Первое знакомство с этим языком было очень непростым, так как с непривычки было очень трудно разобраться с чем мы имеем дело, однако ближе к завершению работы осознание, медленно приходящее ко мне, позволило с интересом и увлеченностью закончить начатое
 При выполнении работы мне не раз приходилось задумываться о том, насколько сложным и объемным получился бы мой код, если бы я захотел поделать подобную работу на том же Си или С++, и как красив и многозначен код Пролога, который обходится буквально в 3 строчки.
